<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>TripleOne – X01 Match</title>
<style>
  :root{
    --bg-a:#0c1444; --bg-b:#17366e;
    --text:#eef3ff; --muted:#a9b6d1;
    --panel:#1b2f60aa; --panel-bd:#2c4b8a;
    --card:#203a73dd; --card-bd:#31579d;
    --radius:14px; --radius-lg:16px; --shadow:0 14px 40px rgba(0,0,0,.35);
    --sidebar-w:240px; --gap:24px; --container-max:1560px;
    --good:#2aa66a; --good2:#1f8c58;

    --dart-w: 140px;
  }
  .dart-icon{ width: var(--dart-w); height:auto; opacity:.85; display:block; }

  *{box-sizing:border-box} html,body{height:100%}
  body{
    margin:0; color:var(--text);
    font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    background:radial-gradient(1100px 700px at 25% 0%, #233f87 0%, transparent 60%),
               linear-gradient(180deg, var(--bg-a), var(--bg-b));
  }

  .app{display:grid; gap:var(--gap); padding:var(--gap);
       grid-template-columns: var(--sidebar-w) 1fr; min-height:100vh;}
  @media (max-width: 680px){ .app{grid-template-columns:1fr} .sidebar{position:relative} }

  .sidebar{
    position:sticky; top:24px; align-self:start; height:fit-content;
    background:var(--panel); border:1px solid var(--panel-bd);
    border-radius:var(--radius-lg); padding:16px; backdrop-filter: blur(6px);
  }
  .brand{display:flex;align-items:center;gap:10px;margin-bottom:16px}
  .brand .logo{width:28px;height:28px;border-radius:8px;background:conic-gradient(from 0deg,#6ea8ff,#79e2ff);box-shadow:var(--shadow)}
  .brand h1{font-size:16px;margin:0;letter-spacing:.6px;font-weight:700}
  .nav{display:flex;flex-direction:column;gap:6px}
  .nav a{display:flex;align-items:center;gap:12px;padding:10px 12px;text-decoration:none;color:#fff;border:1px solid #2a4a8a;background:#132c64a6;border-radius:12px}
  .nav a:hover{background:#1b376eb8}
  .nav a.active{background:#244079;border-color:#3a5fb2}

  .mainwrap{display:flex;justify-content:center}
  .main{width:100%; max-width:var(--container-max)}

  .toolbar{display:flex; gap:8px; flex-wrap:wrap; padding:2px 0 6px 2px}
  .pill{font-size:12px; padding:6px 8px; border:1px solid #3a5fb2; border-radius:12px; background:#18356e; color:#dbe7ff}

  .row{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    gap:14px; align-items:start;
  }
  .score{
    background:var(--card); border:2px solid var(--card-bd); border-radius:var(--radius-lg);
    box-shadow:var(--shadow); padding:10px 12px; transition:border-color .15s, box-shadow .15s;
  }
  .score.active{
  border-color:#ffffffaa;
  box-shadow:inset 0 0 0 3px rgba(255,255,255,.55), var(--shadow);
}
.score-body{ text-align:center; width:100%; }
.score .big{
  font-size:clamp(48px, 8vw, 120px);
  line-height:1.05;
  font-weight:800;
  margin:6px 0 10px;
}
.score-meta{
  display:flex;
  gap:8px;
  justify-content:center;
  align-items:center;
  margin-bottom:6px;
}
/* kleiner grüner Darts-Chip */
.chip{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  min-width:32px;
  padding:2px 8px;
  border-radius:10px;
  background:rgba(16,185,129,0.25);
  border:1px solid rgba(16,185,129,0.4);
  color:#bef7dd;
  font-weight:700;
  font-size:14px;
}

/* Name-Tag wie gehabt */
.tag{
  display:inline-flex; align-items:center; gap:6px;
  background:#132c64a6; border:1px solid #2a4a8a; padding:4px 8px; border-radius:999px;
}
.tag .dot{width:8px;height:8px;border-radius:50%;background:#ffd166}

/* Mini-Zeile: #Besuche | Ø avg */
.score-sub{
  color:#cfe0ff;
  opacity:.9;
  font-size:14px;
}
  .meta{display:flex; align-items:center; gap:8px; padding:6px 8px}
  .tag{display:inline-flex; align-items:center; gap:6px; background:#132c64a6; border:1px solid #2a4a8a; padding:4px 8px; border-radius:999px}
  .tag .dot{width:8px; height:8px; border-radius:50%; background:#ffd166}

  .lanes{ display:grid; grid-template-columns: 240px 1fr 1fr 1fr; gap:14px; margin:10px 0 16px }
  @media (max-width: 960px){ .lanes{ grid-template-columns: 1fr; } }

  .sumBox{
    background:var(--panel); border:1px solid var(--panel-bd); border-radius:12px;
    height:56px; display:grid; place-items:center; color:#fff; font-weight:700; font-size:36px;
  }
    /* Summe zeigen wir groß; bei Bust kurz rot hinterlegt */
  .sumBox.bust{
    background: rgba(180,55,55,.25);
    border-color: rgba(220,100,100,.6);
    color:#ffe8e8;
    font-weight:800;
    letter-spacing:.5px;
  }

  .lane{
    position:relative;
    background:var(--panel); border:1px solid var(--panel-bd);
    border-radius:12px; height:56px; display:grid; place-items:center;
  }
  .dart-icon{ width:var(--dart-w); height:auto; opacity:.85; display:block; }
  .dart-label{
    position:absolute; inset:0; display:grid; place-items:center;
    font-size:26px; font-weight:700; color:#eaf2ff; letter-spacing:.5px;
    opacity:0; transition:opacity .12s ease;
  }

  .pad{
    background:var(--card); border:1px solid var(--card-bd); border-radius:var(--radius-lg);
    box-shadow:var(--shadow); padding:14px; max-width:720px; margin:0 auto;
  }

  /* Tastatur-Grid: 1 Spalte links (Miss/25), 5 Zahlen-Spalten */
  .keypad{
  display:grid;
  grid-template-columns: 136px repeat(5, 1fr);
  gap:0px;
}

.chakra-button{          /* Basis */
  display:flex; align-items:center; justify-content:center;
  height:56px; padding:0 14px; border-radius:12px;
  background:#1d2f58; border:1px solid #28457f; color:#e9efff; font-weight:700;
}
.chakra-button:hover{ background:#223a6e; }

/* Header-Pills (Double/Triple) */
.keyhead{ height:46px; border-radius:999px; background:#163a78; }
.chakra-button.is-active{ outline:2px solid #6ea8ff; }

/* Seitenspalte (Miss/25) – gleiche Optik, höher */
.side{ height:78px; border-radius:12px; background:#163a78; }

/* Zahlen-Keys */
.key{ height:78px; border-radius:14px; background:#163066; }

  /* Header-Toggles */
  .hcell{ display:flex; align-items:center; justify-content:center; color:#e7eeff; font-weight:700; }
  .toggle{
    border:1px solid #2d4f94; background:#163a78; border-radius:999px; cursor:pointer;
    height:48px; width:100%;
  }
  .toggle.active{ outline:2px solid #6ea8ff }

  /* Side-Toggles (Miss / 25) – gleicher Stil, höhere Zelle */
  .toggle.side{
    height:82px; border-radius:12px; font-weight:700;
  }

  .cell{
    border:1px solid #2d4f94; background:#163066; color:#e7eeff; border-radius:12px;
    height:82px; display:grid; place-items:center; cursor:pointer; user-select:none; text-align:center;
    font-weight:600;
  }
  .blank{ visibility:hidden }
  .actions{display:flex; justify-content:space-between; gap:10px; margin-top:8px}
  .btn{appearance:none; border:1px solid #3a5fb2; background:#1a356b; color:#fff; border-radius:14px; padding:12px 16px; cursor:pointer; min-width:140px; height:48px}
  .btn:hover{background:#21417c}
  .btn.primary{background:linear-gradient(180deg, var(--good), var(--good2)); border:none; box-shadow: inset 0 -2px 0 rgba(0,0,0,.15)}

/* Top-Controls rechts */
.topbar {
  display:flex; justify-content:flex-end; align-items:center;
  gap:10px; padding:6px 0 4px;
}
.iconbtn, .pillbtn {
  display:inline-flex; align-items:center; justify-content:center;
  height:34px; min-width:34px; padding:0 10px; gap:8px;
  border-radius:10px; border:1px solid #37559b; background:#18356e;
  color:#dbe7ff; cursor:pointer; user-select:none;
}
.iconbtn:hover, .pillbtn:hover { background:#1c3f7a; }
.iconbtn svg { width:16px; height:16px; opacity:.9; }

/* Abort/Surrender wie Chips */
.pillbtn.danger { border-color:#ff7592; background:#3a2140; color:#ffd7e0; }

/* Modal */
.modal-backdrop{
  position:fixed; inset:0; background:rgba(0,0,0,.45); display:none;
  align-items:center; justify-content:center; z-index:30;
}
.modal{
  width:min(880px, 92vw); max-height:80vh; overflow:auto;
  background:#1b2f60; border:1px solid #2c4b8a; border-radius:16px;
  box-shadow:0 18px 50px rgba(0,0,0,.5); padding:16px;
}
.modal h3{ margin:6px 0 12px; }
.modal .close{ float:right; cursor:pointer; opacity:.8 }
.stat-grid{
  display:grid; grid-template-columns: 1.2fr repeat(5, 1fr); gap:8px;
  align-items:center; margin-top:8px;
}
.stat-grid .th{ font-weight:700; color:#eaf2ff; }
.stat-grid .cell{ background:#163066; border:1px solid #2d4f94; border-radius:8px; padding:8px 10px; }

/* View-Switch Buttons (rechts oben bei deiner Topbar) */
.segment-switch{
  display:inline-flex; border-radius:12px; overflow:hidden; border:1px solid #37559b;
}
.segment-switch button{
  height:34px; min-width:42px; padding:0 10px; display:inline-flex; align-items:center; justify-content:center;
  background:#18356e; color:#dbe7ff; cursor:pointer; border:0;
}
.segment-switch button + button{ border-left:1px solid #37559b; }
.segment-switch button.active{ background:#1c3f7a; outline:2px solid #6ea8ff; }

#heatWrap{
  display:none; position:relative; margin:16px auto; width:min(860px, 92vw);
  aspect-ratio: 1 / 1; /* quadratisch */
  background: radial-gradient(120% 90% at 50% 10%, #26457f 0%, #112355 70%, transparent 100%);
  border:1px solid var(--card-bd); border-radius:16px; box-shadow: var(--shadow);
}
#heatCanvas{ position:absolute; inset:0; width:100%; height:100%; }

.view-toggle{display:flex; gap:8px; margin:8px 0 12px}
.vt-btn{border:1px solid #2a4a8a; background:#132c64a6; color:#fff; border-radius:10px; padding:8px 10px; cursor:pointer}
.vt-btn.is-active{outline:2px solid #6ea8ff}

.hidden{display:none}

.boardWrap{position:relative; width:100%; max-width:900px; margin:0 auto}
.boardSvg svg{display:block; width:100%; height:auto}
#heatCanvas{position:absolute; inset:0; pointer-events:none}

</style>
</head>
<body>
<div class="app">
  <aside class="sidebar">
    <div class="brand"><div class="logo"></div><h1>AUTODARTS</h1></div>
    <nav class="nav">
      <a href="play_dashboard.html">Play</a>
      <a class="active" href="#">Matches</a>
    </nav>
  </aside>

  <div class="mainwrap">
    <main class="main">
      <div class="toolbar" id="toolbar"></div>
      <!-- Rechts oben: kleine Control-Leiste -->
      <div class="topbar">
        <!-- Zuschauer -->
        <button class="iconbtn" title="Viewers">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 5c-7 0-11 7-11 7s4 7 11 7 11-7 11-7-4-7-11-7Zm0 12a5 5 0 1 1 0-10 5 5 0 0 1 0 10Z"/></svg>
          <span id="viewerBadge">1</span>
        </button>
        <!-- Einstellungen (dummys) -->
        <button class="iconbtn" title="Settings">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 8a4 4 0 1 0 0 8 4 4 0 0 0 0-8Zm8.94 3a8.94 8.94 0 0 0-.36-1l2.12-1.65-2-3.46-2.54 1a9.14 9.14 0 0 0-1.73-1l-.39-2.71H9l-.39 2.71a9.14 9.14 0 0 0-1.73 1l-2.54-1-2 3.46L3.46 10a8.94 8.94 0 0 0-.36 1l-2.6.39v4l2.6.39a8.94 8.94 0 0 0 .36 1l-2.12 1.65 2 3.46 2.54-1c.54.4 1.12.74 1.73 1l.39 2.71h4l.39-2.71c.61-.26 1.19-.6 1.73-1l2.54 1 2-3.46L20.54 17c.15-.32.27-.66.36-1l2.6-.39v-4l-2.56-.39Z"/></svg>
        </button>
        <!-- Statistik -->
        <button class="iconbtn" id="btnStats" title="Match statistics">
          <svg viewBox="0 0 24 24" fill="currentColor"><path d="M4 21h16v-2H4v2Zm2-4h3V8H6v9Zm5 0h3V4h-3v13Zm5 0h3v-6h-3v6Z"/></svg>
        </button>
        <!-- Dummy: Abort / Surrender -->
        <button class="pillbtn danger" id="btnAbort">Abort</button>
        <button class="pillbtn danger" id="btnSurrender">Surrender</button>

        <div class="segment-switch" style="margin-right:8px">
          <button id="btnViewKey" class="active" title="Tastatur">
            <!-- Keyboard Icon -->
            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M4 5h16a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2Zm1 3v2h2V8H5Zm3 0v2h2V8H8Zm3 0v2h2V8h-2Zm3 0v2h2V8h-2Zm3 0v2h2V8h-2ZM5 12v2h2v-2H5Zm3 0v2h8v-2H8Zm11 0v2h2v-2h-2Z"/></svg>
          </button>
          <button id="btnViewHeat" title="Heat-Map">
            <!-- Circle/record Icon -->
            <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor"><path d="M12 3a9 9 0 1 0 .001 18.001A9 9 0 0 0 12 3Zm0 13a4 4 0 1 1 0-8 4 4 0 0 1 0 8Z"/></svg>
          </button>
        </div>

      </div>

      <!-- Statistik-Modal -->
      <div class="modal-backdrop" id="statsModal">
        <div class="modal">
          <span class="close" id="statsClose">✕</span>
          <h3>Match statistics</h3>
          <div id="statsContent"></div>
        </div>
      </div>


      <div class="row" id="scoreRow"></div>

      <div class="lanes">
        <div class="sumBox" id="sumBox">0</div>
        <!-- in deinen Lanes: KEIN inline-style nötig -->
          <div class="lane"><img class="dart-icon" alt=""><div class="dart-label"></div></div>
          <div class="lane"><img class="dart-icon" alt=""><div class="dart-label"></div></div>
          <div class="lane"><img class="dart-icon" alt=""><div class="dart-label"></div></div>
      </div>
      <div id="heatWrap">
        <canvas id="heatCanvas"></canvas>
      </div>

      <section class="pad">
        <div class="keypad" id="padGrid">
          <!-- Kopfzeile -->
          <div></div>
          <button class="chakra-button keyhead" id="tDouble" style="grid-column:2 / span 2">Double</button>
          <button class="chakra-button keyhead" id="tTriple" style="grid-column:4 / span 3">Triple</button>
        
          <!-- Zeile 1: 25 links, S20–S16 rechts -->
          <button class="chakra-button side" id="btn25">25</button>
          <button class="chakra-button key" data-n="20">S20</button>
          <button class="chakra-button key" data-n="19">S19</button>
          <button class="chakra-button key" data-n="18">S18</button>
          <button class="chakra-button key" data-n="17">S17</button>
          <button class="chakra-button key" data-n="16">S16</button>
        
          <!-- Zeile 2: Miss links, S15–S11 rechts -->
          <button class="chakra-button side" id="btnMiss">Miss</button>
          <button class="chakra-button key" data-n="15">S15</button>
          <button class="chakra-button key" data-n="14">S14</button>
          <button class="chakra-button key" data-n="13">S13</button>
          <button class="chakra-button key" data-n="12">S12</button>
          <button class="chakra-button key" data-n="11">S11</button>
        
          <!-- Zeile 3: S10–S6 (linke Spalte leer) -->
          <div></div>
          <button class="chakra-button key" data-n="10">S10</button>
          <button class="chakra-button key" data-n="9">S9</button>
          <button class="chakra-button key" data-n="8">S8</button>
          <button class="chakra-button key" data-n="7">S7</button>
          <button class="chakra-button key" data-n="6">S6</button>
        
          <!-- Zeile 4: S5–S1 (linke Spalte leer) -->
          <div></div>
          <button class="chakra-button key" data-n="5">S5</button>
          <button class="chakra-button key" data-n="4">S4</button>
          <button class="chakra-button key" data-n="3">S3</button>
          <button class="chakra-button key" data-n="2">S2</button>
          <button class="chakra-button key" data-n="1">S1</button>
        </div>        

        <div class="actions">
          <button class="btn" id="btnUndo">↩︎ Undo</button>
          <button class="btn primary" id="btnNext">Next</button>
        </div>
      </section>
    </main>
  </div>
</div>

<script>
  // ------- Payload -------
  const game = (() => {
    try { const p = sessionStorage.getItem('game_payload'); if (p) return JSON.parse(p); } catch {}
    return { gameType:'X01', settings:{base:'501', inMode:'Straight', outMode:'Double', maxRounds:'50'},
             players:[{name:'PICUS'},{name:'PATRICK'}] };
  })();
  const BASE = parseInt(String(game.settings.base||'501'),10)||501;
  const MAXR = parseInt(String(game.settings.maxRounds||'50'),10)||50;

  // ------- Toolbar -------
  function addPill(t){
    const el=document.createElement('span');
    el.className='pill'; el.textContent=t;
    document.getElementById('toolbar').appendChild(el);
  }
  (function(){
    const m={Straight:'S',Double:'D',Master:'M'};
    addPill('X01'); addPill(String(BASE));
    addPill(`${m[game.settings.inMode]||'S'}I-${m[game.settings.outMode]||'S'}O`);
    if(game.settings.matchMode==='sets') addPill('S'+(game.settings.setsToWin||2));
    else if(game.settings.matchMode==='legs') addPill('L'+(game.settings.legsToWin||2));
    addPill('R1/'+MAXR);
  })();

  // ------- State -------
  const state = {
    players: game.players.map(p=>({name:p.name, score:BASE})),
    curPlayer: 0,
    darts: [],           // max 3: {ring,n,label,value}
    history: [],         // {type:'THROW'|'NEXT'|'BUST', ...}
    finished: false,     // Leg zu Ende? -> Eingaben sperren
    turnStartScore: BASE,
    bustFlash: false,    // kurz "BUST"
    visitEnded: false,   // Aufnahme ist beendet, wartet auf Pfeilentfernung
    stuckDarts: 0        // wie viele Pfeile stecken im Board (Miss zählt nicht)
  };




  // --- Scorecard HTML ----------------------------------------------------
  function scoreCard(p, i){
    const s = playerStats(i);
    return `
      <section class="score ${i===state.curPlayer ? 'active' : ''}">
        <div class="score-body">
          <div class="big" id="sc${i}">${p.score}</div>

          <div class="score-meta">
            <span class="chip" title="geworfene Darts">${s.darts}</span>
            <span class="tag"><span class="dot"></span><b>${p.name}</b></span>
          </div>

          <div class="score-sub">#${s.visits} | Ø ${s.threeAvg} / ${s.oneAvg}</div>
        </div>
      </section>
    `;
  }

  // --- Stats pro Spieler -------------------------------------------------
  function playerStats(idx){
    // geworfene Darts & Besuche (Aufnahmen)
    let darts = 0;
    for(const h of state.history){
      if(h.type === 'THROW' && h.player === idx) darts++;
    }
    const visits = Math.ceil(darts / 3);

    const scored = BASE - state.players[idx].score;           // erzielte Punkte
    const oneAvg = darts > 0 ? (scored / darts) : 0;          // 1-Dart-Ø
    const threeAvg = darts > 0 ? oneAvg * 3 : 0;              // 3-Dart-Ø

    return {
      darts,
      visits,
      oneAvg: oneAvg.toFixed(1),
      threeAvg: threeAvg.toFixed(1)
    };
  }

  function renderScores(){
    const row = document.getElementById('scoreRow');
    row.innerHTML = state.players.map(scoreCard).join('');
  }

// call initially
renderScores();
state.turnStartScore = state.players[state.curPlayer].score;

const padEl   = document.querySelector('.pad');
const heatEl  = document.getElementById('heatWrap');
const btnKey  = document.getElementById('btnViewKey');
const btnHeat = document.getElementById('btnViewHeat');

function setView(mode){
  const isHeat = (mode === 'heat');
  padEl.style.display  = isHeat ? 'none' : 'block';
  heatEl.style.display = isHeat ? 'block' : 'none';
  btnKey.classList.toggle('active', !isHeat);
  btnHeat.classList.toggle('active', isHeat);
  if(isHeat) drawHeat(); // sicherstellen, dass Canvas dimensions korrekt sind
}
btnKey.addEventListener('click', ()=>setView('key'));
btnHeat.addEventListener('click', ()=>setView('heat'));


  // ------- Lanes + Sum -------
  const sumBox = document.getElementById('sumBox');
  const laneEls = [...document.querySelectorAll('.lane')];
  function refreshLanes(){
    laneEls.forEach((box,i)=>{
      const icon = box.querySelector('.dart-icon');
      const lbl  = box.querySelector('.dart-label');
      const d = state.darts[i];
      if(d){ lbl.textContent = d.label; lbl.style.opacity = 1; icon.style.opacity = 0; }
      else { lbl.textContent = '';       lbl.style.opacity = 0; icon.style.opacity = .85; }
    });

    if(state.bustFlash){
      sumBox.classList.add('bust');
      sumBox.textContent = 'BUST';
    } else {
      sumBox.classList.remove('bust');
      const s = state.darts.reduce((a,t)=>a + (t?.value||0), 0);
      sumBox.textContent = String(s);
    }
  }

  refreshLanes();

  // --- Dart-Icon als Data-URI (dein SVG) ------------------------------
const DART_SVG = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='UTF-8'?%3e%3csvg%20id='Laag_1'%20data-name='Laag%201'%20xmlns='http://www.w3.org/2000/svg'%20version='1.1'%20viewBox='0%200%20477%20102'%3e%3cdefs%3e%3cstyle%3e%20.cls-1%20{%20fill:%20%23fff;%20stroke-width:%200px;%20}%20%3c/style%3e%3c/defs%3e%3cg%20id='Union_1'%20data-name='Union%201'%3e%3cpath%20class='cls-1'%20d='M26.56.5h53.65l.14.11,55.78,45,42.2-.07,42.49.07c.95-.56,6.88-4,10.06-4h152.73c2.11,0,4.43.36,6.9,1.07,1.96.56,4.03,1.35,6.13,2.34,3.16,1.48,5.42,2.94,5.98,3.31,2.04,0,23.83-.1,40.68-.1,10.34,0,16.83.03,19.29.1,5.75.16,13.13,1.98,13.95,2.19h.02s-.12.48-.12.48h0s.12.5.12.5h-.02c-.82.21-8.2,2.02-13.95,2.19-2.45.07-8.94.1-19.29.1-16.85,0-38.64-.09-40.68-.1-.56.37-2.82,1.83-5.98,3.31-3.32,1.55-8.27,3.41-13.03,3.41h-152.73c-3.19,0-9.11-3.44-10.06-4l-42.49.07-42.2-.07-55.78,45-.14.11H26.56l-.14-.27L1,51.23l-.12-.23.12-.23L26.43.77l.14-.27Z'%20/%3e%3c/g%3e%3c/svg%3e";

document.querySelectorAll('.dart-icon').forEach(img => {
  img.src = DART_SVG;
});


  // ------- Ringwahl (Single default) -------
  let ring = 'S';                                // <<< WICHTIG: fehlte bei dir
  const btnD = document.getElementById('tDouble');
  const btnT = document.getElementById('tTriple');

  function resetRingToSingle(){
    ring = 'S';
    btnD.classList.remove('is-active');
    btnT.classList.remove('is-active');
  }

  function setRing(r){
    if(ring === r){
      ring = 'S';
      btnD.classList.remove('is-active');
      btnT.classList.remove('is-active');
      return;
    }
    ring = r;
    btnD.classList.toggle('is-active', r==='D');
    btnT.classList.toggle('is-active', r==='T');
  }
  btnD.onclick = () => setRing('D');
  btnT.onclick = () => setRing('T');


  document.getElementById('btn25').onclick  = () => {
    if(state.finished) return;                  // <<< neu
    const isD = (ring==='D');
    addThrow({ring:isD?'D':'S', n:25, value:isD?50:25, label:isD?'D25':'25'});
    resetRingToSingle();
  };


  // ------- Feld-Klicks (vereinheitlicht auf [data-n]) -------
  document.getElementById('padGrid').addEventListener('click', (e)=>{
    const key = e.target.closest('[data-n]');
    if(!key || state.darts.length >= 3 || state.finished) return;

    const n = parseInt(key.dataset.n, 10);
    if (n === 25) {
      const isD = (ring === 'D');
      addThrow({ring:isD?'D':'S', n:25, value:isD?50:25, label:isD?'D25':'25'});
      resetRingToSingle();               // <<< hier zurück auf Single
      return;
    }
    const mult = ring==='D' ? 2 : ring==='T' ? 3 : 1;
    addThrow({ring, n, value: mult*n, label: `${ring}${n}`});
    resetRingToSingle();                 // <<< hier zurück auf Single
  });
  // ------- Miss & 25 Buttons (links) -------
  document.getElementById('btnMiss').onclick = () => {
    if(state.finished) return;
    addThrow({ring:'M', n:0, value:0, label:'0'});
    resetRingToSingle();                 // <<< zurücksetzen
  };


  // ------- Common actions -------
  function addThrow(obj){
    if(state.finished) return;

    // Aufnahme-Startscore merken
    if(state.darts.length === 0){
      state.turnStartScore = state.players[state.curPlayer].score;
    }

    const outMode = (game.settings.outMode || 'Double'); // "Double" | "Straight" | "Master"
    const cur = state.players[state.curPlayer];
    const tentativeNew = cur.score - obj.value;

    // Checkout-Gültigkeit
    const isDouble = (obj.ring === 'D');
    const finishValid =
          (outMode === 'Double')  ? isDouble :
          (outMode === 'Master')  ? (obj.ring === 'D' || obj.ring === 'T') :
                                    true; // Straight

    // Bust?
    const isBust =
        (tentativeNew < 0) ||
        (outMode === 'Double' && tentativeNew === 1) ||
        (tentativeNew === 0 && !finishValid);

    // Wurf aufnehmen
    state.darts.push(obj);
    state.history.push({type:'THROW', player:state.curPlayer, ...obj});

    // stuckDarts nur erhöhen, wenn kein Miss (label '0' oder ring 'M' ist Miss)
    const isMiss = (obj.label === '0' || obj.ring === 'M');
    if(!isMiss) state.stuckDarts++;

    if(isBust){
      // Score revertieren & Bust loggen
      cur.score = state.turnStartScore;
      state.history.push({type:'BUST', player:state.curPlayer});

      // Bust nur kurz anzeigen, danach auf Pfeilentfernung warten
      state.bustFlash = true;
      state.visitEnded = true;          // Aufnahme endet mit Bust
      renderScores(); refreshLanes();
      setTimeout(()=>{ state.bustFlash = false; refreshLanes(); }, 700);
      // KEIN nextPlayer hier – checkAutoNext übernimmt, sobald stuckDarts == 0
      return;
    }

    // normal zählen
    cur.score = tentativeNew;
    renderScores(); refreshLanes();

    // Checkout?
    if(tentativeNew === 0){
      state.finished = true;            // Leg zu Ende -> sperren
      document.body.insertAdjacentHTML('beforeend',
        `<div id="legToast" style="position:fixed;inset:auto 0 24px 0;display:flex;justify-content:center;pointer-events:none">
          <div style="background:#1f2937cc;border:1px solid #6ee7b7;padding:10px 14px;border-radius:12px;color:#d1fae5;font-weight:700">
            Leg finished!
          </div>
        </div>`);
      setTimeout(()=> document.getElementById('legToast')?.remove(), 1500);
      return;
    }

    // 3 Würfe voll -> Aufnahme beendet, aber erst wechseln wenn Darts gezogen
    if(state.darts.length >= 3){
      state.visitEnded = true;
      checkAutoNext();   // wechselt erst, wenn stuckDarts == 0
    }
  }

  // --- optionaler Fake-Hit für die Heatmap (grob auf Ring-Mitte) ---
  (function fakeHeatFromLabel(){
    if(heatEl.style.display === 'none') return; // nur wenn sichtbar
    const label = obj.label; // z.B. "S20", "D18", "T7", "0"
    if(label === '0') return;

    // Ring -> Radius
    const rmap = { 'S': 0.75, 'D': 0.95, 'T': 0.58 }; // grobe Ringmitten
    const ringR = rmap[obj.ring] || 0.85;
    // Segment -> Winkel (20 oben, dann im Uhrzeigersinn alle 18°)
    const order = [20,1,18,4,13,6,10,15,2,17,3,19,7,16,8,11,14,9,12,5];
    const idx = order.indexOf(obj.n);
    if(idx >= 0){
      const angle = idx * 18; // 0,18,36,...
      // kleine Streuung
      const jitterR = (Math.random()-0.5)*0.04;
      const jitterA = (Math.random()-0.5)*5;
      addHitPolar(Math.min(1, Math.max(0, ringR + jitterR)), angle + jitterA, 0.9);
    }
  })();


  function undo(){
    const last = state.history.pop(); if(!last) return;
    state.finished = false;   // nach Undo wieder freigeben

    if(last.type === 'NEXT'){
      state.curPlayer = last.prev;
      state.darts = collectTurn(state.curPlayer);
      state.visitEnded = (state.darts.length >= 3); // ggf. wieder offen
      renderScores(); refreshLanes(); 
      return;
    }

    if(last.type === 'BUST'){
      // Bust-Eintrag rückgängig -> davor war ein THROW
      const t = state.history.pop();
      if(t && t.type === 'THROW'){
        state.players[t.player].score += t.value;
        // stuckDarts korrigieren (nur wenn kein Miss war)
        const wasMiss = (t.label === '0' || t.ring === 'M');
        if(!wasMiss && state.stuckDarts > 0) state.stuckDarts--;
        // der Wurf war schon in state.darts (Bust addThrow nimmt ihn dazu): entferne ihn wieder
        if(state.darts.length) state.darts.pop();
      }
      state.visitEnded = false;
      renderScores(); refreshLanes();
      return;
    }

    // normaler Throw
    state.players[last.player].score += last.value;
    const wasMiss = (last.label === '0' || last.ring === 'M');
    if(!wasMiss && state.stuckDarts > 0) state.stuckDarts--;

    if(last.player === state.curPlayer){
      if(state.darts.length) state.darts.pop();
    }else{
      state.curPlayer = last.player;
      const t = collectTurn(state.curPlayer); t.pop(); state.darts = t;
    }
    state.visitEnded = (state.darts.length >= 3) ? true : false;
    renderScores(); refreshLanes();
  }

  function nextPlayer(){
    if(state.finished) return;
    state.history.push({type:'NEXT', prev:state.curPlayer});
    state.curPlayer = (state.curPlayer+1)%state.players.length;
    state.darts = [];
    state.visitEnded = false;
    state.stuckDarts = 0;
    state.turnStartScore = state.players[state.curPlayer].score;
    renderScores(); refreshLanes();
  }


  function collectTurn(player){
    const res=[]; 
    for(let i=state.history.length-1;i>=0;i--){
      const h=state.history[i];
      if(h.type==='NEXT'){ if(h.prev===player) break; else continue; }
      if(h.player===player) res.unshift({ring:h.ring,n:h.n,label:h.label,value:h.value});
    }
    return res.slice(-3);
  }

  document.getElementById('btnUndo').onclick = undo;
  document.getElementById('btnNext').onclick = nextPlayer;

  document.getElementById('btn25').onclick  = () => {
    if(state.finished) return;                    // <<< neu
    const isD = (ring==='D');
    addThrow({ring:isD?'D':'S', n:25, value:isD?50:25, label:isD?'D25':'25'});
    resetRingToSingle();
  };

  function onDartRemoved(){
    if(state.stuckDarts > 0) state.stuckDarts--;
    checkAutoNext();
  }
  function onAllDartsRemoved(){
    state.stuckDarts = 0;
    checkAutoNext();
  }
  function checkAutoNext(){
    // Nur wechseln, wenn die Aufnahme beendet ist und keine Pfeile mehr stecken
    if(state.visitEnded && !state.finished && state.stuckDarts === 0){
      // Aufnahme visuell aufräumen
      state.darts = [];
      state.visitEnded = false;
      renderScores(); refreshLanes();
      nextPlayer();
    }
  }

  // Public + Event-Hook für den Detector/Agent
  window.tripleOne = window.tripleOne || {};
  window.tripleOne.dartRemoved = onDartRemoved;
  window.tripleOne.allRemoved  = onAllDartsRemoved;
  window.addEventListener('tripleone:dart_removed', onDartRemoved);
  window.addEventListener('tripleone:all_removed', onAllDartsRemoved);


  //Nur zum Testen
  document.addEventListener('keydown', (e) => {
    if (e.key === 'r') window.tripleOne.dartRemoved();   // r = remove one
    if (e.key === 'a') window.tripleOne.allRemoved();    // a = all removed
  });

  // --- Statistiken pro Spieler aus state.history berechnen ---
function computeMatchStats(){
  const P = state.players.length;
  const res = Array.from({length:P}, (_,i)=>({
    name: state.players[i].name,
    darts: 0, visits: 0,
    oneAvg: 0, threeAvg: 0,
    v60:0, v100:0, v140:0, bestVisit:0
  }));

  // Besuchswerte pro Spieler sammeln
  const curVisit = Array.from({length:P}, ()=>0);
  const curDarts = Array.from({length:P}, ()=>0);

  function closeVisit(p){               // Besuch abschließen
    if(curDarts[p]===0) return;
    res[p].visits++;
    res[p].darts += curDarts[p];
    res[p].bestVisit = Math.max(res[p].bestVisit, curVisit[p]);
    const v = curVisit[p];
    if(v>=140) res[p].v140++; else if(v>=100) res[p].v100++; else if(v>=60) res[p].v60++;
    curVisit[p]=0; curDarts[p]=0;
  }

  for(const h of state.history){
    if(h.type==='THROW'){
      curVisit[h.player]+= h.value;
      curDarts[h.player]+= 1;
    }else if(h.type==='BUST'){
      // Bust beendet die Aufnahme mit 0 Punkten in der Visit-Summe
      const p = h.player;
      // Darts wurden schon bei THROW gezählt; Visit schließen
      closeVisit(p);
    }else if(h.type==='NEXT'){
      closeVisit(h.prev);
    }
  }
  // laufende Visits am Ende schließen
  for(let p=0;p<P;p++) closeVisit(p);

  // Averages berechnen
  for(const r of res){
    const scored = BASE*r.visits*3 - (/* not exact if Legs >1 */ 0); // Verwendung history für exakte Punkte ist simpler:
  }
  // exakte Punkte aus History (summe aller geworfenen Werte minus Bust-Rücknahmen)
  const scoredByP = Array.from({length:P}, ()=>0);
  for(const h of state.history){
    if(h.type==='THROW') scoredByP[h.player]+=h.value;
    if(h.type==='BUST'){ /* nothing */ }
  }
  for(let i=0;i<P;i++){
    const r = res[i];
    const pts = scoredByP[i];
    r.oneAvg   = r.darts ? (pts / r.darts) : 0;
    r.threeAvg = r.darts ? (r.oneAvg * 3) : 0;
    r.oneAvg   = r.oneAvg.toFixed(1);
    r.threeAvg = r.threeAvg.toFixed(1);
  }
  return res;
}

function renderStatsModal(){
  const stats = computeMatchStats();
  const el = document.getElementById('statsContent');
  // Tabelle
  let html = `<div class="stat-grid">
    <div></div>
    <div class="th">Darts</div>
    <div class="th">Visits</div>
    <div class="th">Ø/1</div>
    <div class="th">Ø/3</div>
    <div class="th">Best</div>
  </div>`;
  for(const s of stats){
    html += `<div class="stat-grid">
      <div class="cell"><b>${s.name}</b></div>
      <div class="cell">${s.darts}</div>
      <div class="cell">${s.visits}</div>
      <div class="cell">${s.oneAvg}</div>
      <div class="cell">${s.threeAvg}</div>
      <div class="cell">${s.bestVisit}</div>
    </div>`;
  }
  // zweite Reihe: 60+/100+/140+
  html += `<div style="height:8px"></div>
           <div class="stat-grid">
            <div></div>
            <div class="th">60+</div><div class="th">100+</div><div class="th">140+</div>
            <div></div><div></div>
           </div>`;
  for(const s of stats){
    html += `<div class="stat-grid">
      <div class="cell"><b>${s.name}</b></div>
      <div class="cell">${s.v60}</div>
      <div class="cell">${s.v100}</div>
      <div class="cell">${s.v140}</div>
      <div></div><div></div>
    </div>`;
  }
  el.innerHTML = html;
}

function openStats(){ renderStatsModal(); document.getElementById('statsModal').style.display='flex'; }
function closeStats(){ document.getElementById('statsModal').style.display='none'; }

document.getElementById('btnStats').addEventListener('click', openStats);
document.getElementById('statsClose').addEventListener('click', closeStats);
document.getElementById('statsModal').addEventListener('click', (e)=>{ if(e.target.id==='statsModal') closeStats(); });

// Dummies
document.getElementById('btnAbort').onclick = ()=>alert('Abort (stub)');
document.getElementById('btnSurrender').onclick = ()=>alert('Surrender (stub)');

// --- Heat-Map Daten ---
const heat = {
  hits: [],          // {x,y,intensity} in Canvas-Pixeln
  byPlayer: {}       // optional pro Spieler sammeln
};

function getCanvasAndCtx(){
  const canvas = document.getElementById('heatCanvas');
  const rect = canvas.parentElement.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  canvas.width  = Math.floor(rect.width  * dpr);
  canvas.height = Math.floor(rect.height * dpr);
  const ctx = canvas.getContext('2d');
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // 1 CSS-px = 1 unit
  return {canvas, ctx, w: rect.width, h: rect.height};
}

function drawBoard(ctx, w, h){
  const cx = w/2, cy = h/2;
  const R  = Math.min(w,h)*0.47;

  // Grund
  ctx.fillStyle = '#101726';
  ctx.fillRect(0,0,w,h);

  // Glow
  const g = ctx.createRadialGradient(cx, cy, R*0.65, cx, cy, R*1.05);
  g.addColorStop(0, 'rgba(255,0,0,0.10)');
  g.addColorStop(1, 'rgba(255,0,0,0.0)');
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(cx,cy,R*1.05,0,Math.PI*2); ctx.fill();

  // Außenring + Segmente grob
  ctx.fillStyle = '#0c0c0f';
  ctx.beginPath(); ctx.arc(cx,cy,R,0,Math.PI*2); ctx.fill();

  // Doppel / Triple / Single & Bulls – minimalistisch
  function ring(col, o, i){
    ctx.fillStyle = col;
    ctx.beginPath(); ctx.arc(cx,cy,R*o,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#0c0c0f';
    ctx.beginPath(); ctx.arc(cx,cy,R*i,0,Math.PI*2); ctx.fill();
  }
  ring('rgba(210,64,70,0.85)', 0.98, 0.90); // Double
  ring('rgba(52,199,89,0.85)', 0.62, 0.54); // Triple
  // Bulls
  ctx.fillStyle = '#34c759'; ctx.beginPath(); ctx.arc(cx,cy,R*0.07,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#d53d43'; ctx.beginPath(); ctx.arc(cx,cy,R*0.025,0,Math.PI*2); ctx.fill();
}

function drawHeat(){
  const {ctx,w,h} = getCanvasAndCtx();
  drawBoard(ctx, w, h);

  // Heat-Spots
  for(const hit of heat.hits){
    const r = Math.min(w,h) * 0.045; // Fleckgröße
    const grd = ctx.createRadialGradient(hit.x, hit.y, 0, hit.x, hit.y, r);
    grd.addColorStop(0, `rgba(255,80,80,${0.70 * (hit.intensity||1)})`);
    grd.addColorStop(1, 'rgba(255,80,80,0)');
    ctx.fillStyle = grd;
    ctx.beginPath();
    ctx.arc(hit.x, hit.y, r, 0, Math.PI*2);
    ctx.fill();
  }

  // dünne Glas-Schicht
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.lineWidth = 1;
  ctx.strokeRect(0.5,0.5,w-1,h-1);
}

// Öffentliche API für deinen Detector/Agent:
// 1) Pixelkoordinaten (Canvas-Space)
function addHitPx(x, y, intensity=1){
  const {w,h} = getCanvasAndCtx();
  heat.hits.push({ x: Math.max(0, Math.min(w, x)), y: Math.max(0, Math.min(h, y)), intensity });
  if(heat.hits.length > 400) heat.hits.shift(); // einfacher Ringpuffer
  if(heatEl.style.display !== 'none') drawHeat();
}

// 2) Polarkoordinaten (normierter Radius 0..1, Winkel in Grad, 0° nach oben, CW)
function addHitPolar(rNorm, angleDeg, intensity=1){
  const {w,h} = getCanvasAndCtx();
  const cx = w/2, cy = h/2;
  const R  = Math.min(w,h)*0.47;
  const rad = (angleDeg - 90) * Math.PI/180; // 0° oben
  const x = cx + Math.cos(rad) * (rNorm * R);
  const y = cy + Math.sin(rad) * (rNorm * R);
  addHitPx(x, y, intensity);
}

// 3) Leeren (z.B. beim Leg-Start)
function clearHeat(){ heat.hits.length = 0; if(heatEl.style.display !== 'none') drawHeat(); }

// Hooks exportieren
window.tripleOne = window.tripleOne || {};
window.tripleOne.addHitPx    = addHitPx;
window.tripleOne.addHitPolar = addHitPolar;
window.tripleOne.clearHeat   = clearHeat;

// bei Resize neu zeichnen, wenn sichtbar
window.addEventListener('resize', ()=>{ if(heatEl.style.display !== 'none') drawHeat(); });

// --- View switch (Keyboard <-> Heat) ---
const elKeys  = document.getElementById('viewKeys');
const elHeat  = document.getElementById('viewHeat');
const bKeys   = document.getElementById('btnViewKeys');
const bHeat   = document.getElementById('btnViewHeat');
bKeys.onclick = () => { bKeys.classList.add('is-active'); bHeat.classList.remove('is-active'); elKeys.classList.remove('hidden'); elHeat.classList.add('hidden'); };
bHeat.onclick = () => { bHeat.classList.add('is-active'); bKeys.classList.remove('is-active'); elHeat.classList.remove('hidden'); elKeys.classList.add('hidden'); sizeHeat(); drawHeat(); };

// --- Heat-Board laden (deine SVG) ---
const boardHost = document.getElementById('boardSvg');
const heatCanvas = document.getElementById('heatCanvas');
const hctx = heatCanvas.getContext('2d', { alpha:true });

let svgEl = null;              // referenz aufs geladene <svg>
let Rpx   = 0;                 // Board-Radius in Pixeln (für Projektion)
let cx    = 0, cy = 0;         // Canvas-Zentrum

(async function loadBoardSvg(){
  const txt = await fetch('assets/heat_board.svg').then(r=>r.text());
  boardHost.innerHTML = txt;
  svgEl = boardHost.querySelector('svg');
  sizeHeat();  // initiale Canvas-Größe
  drawHeat();  // erste Zeichnung
})();

// Canvas an SVG-Box anpassen
function sizeHeat(){
  if(!svgEl) return;
  const box = svgEl.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  heatCanvas.style.width  = box.width  + 'px';
  heatCanvas.style.height = box.height + 'px';
  heatCanvas.width  = Math.round(box.width  * dpr);
  heatCanvas.height = Math.round(box.height * dpr);

  // Mittelpunkt + Radius in Pixeln (SVG ist quadratisch, Board-Radius ~ Hälfte)
  cx = heatCanvas.width/2;
  cy = heatCanvas.height/2;
  Rpx = Math.min(heatCanvas.width, heatCanvas.height)/2;
}
window.addEventListener('resize', ()=>{ if(!elHeat.classList.contains('hidden')) { sizeHeat(); drawHeat(); }});

// --- Heat-Daten und Malroutine (Beispiel) ---
const heat = {
  // Beispielpunkte: angle in Grad (0 = oben), rNorm: 0..1 (1 = Double-Außen)
  hits: [
    { angleDeg: -10, rNorm: 0.95, weight: 1.0 },  // nahe Double 20
    { angleDeg: 0,   rNorm: 0.60, weight: 0.8  }, // Single Top
  ]
};

function drawHeat(){
  if(!svgEl) return;
  const ctx = hctx;
  ctx.clearRect(0,0,heatCanvas.width, heatCanvas.height);

  for(const p of heat.hits){
    // Projektion: 0° oben, im Uhrzeigersinn (SVG ist so orientiert)
    const a = (p.angleDeg - 90) * Math.PI/180; // -90, damit 0° oben
    const r = Math.min(Math.max(p.rNorm,0),1) * Rpx;
    const x = cx + r * Math.cos(a);
    const y = cy + r * Math.sin(a);
    drawBlob(ctx, x, y, 18 * (window.devicePixelRatio||1), p.weight||1);
  }
}

// weicher Punkt
function drawBlob(ctx, x, y, radius, strength){
  const g = ctx.createRadialGradient(x,y,0, x,y,radius);
  g.addColorStop(0, `rgba(255, 0, 0, ${0.25*strength})`);
  g.addColorStop(1, 'rgba(255, 0, 0, 0)');
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation = 'source-over';
}

function onConfirmedHit(sector, ring){
  // Beispiel: aus S/D/T + Zahl -> Winkel & Radius schätzen
  const sectorOrder = [20,1,18,4,13,6,10,15,2,17,3,19,7,16,8,11,14,9,12,5];
  const idx = sectorOrder.indexOf(sector); // 0..19
  const angleDeg = (idx * (360/20));       // Mitte des Sektors

  // grobe Ringradien (0..1): Single = 0.57 oder 0.92, Triple = 0.58..0.62, Double = ~0.95
  const rMap = { S:0.78, T:0.58, D:0.95, BULL:0.03, OUTER:0.07 };
  const rNorm = rMap[ring] ?? 0.78;

  heat.hits.push({ angleDeg, rNorm, weight: 1.0 });
  if(!elHeat.classList.contains('hidden')) drawHeat();
}


</script>
<script>
  window.TRIPLEONE_API = 'http://127.0.0.1:8017';
  window.TRIPLEONE_CAMERA = 'cam0';  // oder '' für alle Kameras
</script>
<!-- WICHTIG: x01_game.html liegt in assets/, also relativer Pfad ohne "assets/" -->
<script src="auto_hits_addThrow.js"></script>




</body>
</html>











